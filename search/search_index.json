{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"azint azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins. Geometry The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI Installation conda install -c maxiv azint Getting started azint is using poni files from pyFAI to setup the azimuthal integrator import fabio import numpy as np from azint import AzimuthalIntegrator img = fabio . open ( 'Eiger4M_Al2O3_13.45keV.edf' ) . data mask = fabio . open ( 'mask.tif' ) . data # 1D integration ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , 2000 , unit = 'q' , solid_angle = True , mask = mask ) I , sigma = ai . integrate ( img ) import matplotlib.pyplot as plt plt . figure () plt . plot ( ai . radial_axis , I ) # 2D integration ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , 512 , 180 , unit = 'q' , solid_angle = True , mask = mask ) I , sigma = ai . integrate ( img ) plt . figure () plt . imshow ( I )","title":"Home"},{"location":"#azint","text":"azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins.","title":"azint"},{"location":"#geometry","text":"The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI","title":"Geometry"},{"location":"#installation","text":"conda install -c maxiv azint","title":"Installation"},{"location":"#getting-started","text":"azint is using poni files from pyFAI to setup the azimuthal integrator import fabio import numpy as np from azint import AzimuthalIntegrator img = fabio . open ( 'Eiger4M_Al2O3_13.45keV.edf' ) . data mask = fabio . open ( 'mask.tif' ) . data # 1D integration ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , 2000 , unit = 'q' , solid_angle = True , mask = mask ) I , sigma = ai . integrate ( img ) import matplotlib.pyplot as plt plt . figure () plt . plot ( ai . radial_axis , I ) # 2D integration ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , 512 , 180 , unit = 'q' , solid_angle = True , mask = mask ) I , sigma = ai . integrate ( img ) plt . figure () plt . imshow ( I )","title":"Getting started"},{"location":"azint-reference/","text":"AzimuthalIntegrator This class is an azimuthal integrator __init__ ( self , poni_file , shape , pixel_size , n_splitting , radial_bins , azimuth_bins = None , unit = 'q' , mask = None , solid_angle = True , polarization_factor = None , error_model = None ) special Parameters: Name Type Description Default poni_file str Name of Poni file that sets up the geometry of the integrator required shape tuple Shape of the images to be integrated required pixel_size float Pixel size of detector required n_splitting int Each pixel in the image gets split into (n, n) subpixels that get binned individually required radial_bins Union[int, collections.abc.Sequence] radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1. required azimuth_bins Union[int, collections.abc.Sequence] azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees. None unit str Ouput units for the radial coordindate 'q' mask ndarray Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded None solid_angle bool Perform solid angle correction True polarization_factor Optional[float] Polarization factor for the polarization correction 1 (linear horizontal polarization) -1 (linear vertical polarization) None Attributes: Name Type Description radial_axis ndarray radial axis depeding on units in q or 2theta azimuth_axis ndarray azimuth axis in degrees is case of 2D integration Source code in azint/azint.py def __init__ ( self , poni_file : str , shape : tuple [ int , int ], pixel_size : float , n_splitting : int , radial_bins : Union [ int , Sequence ], azimuth_bins : Optional [ Union [ int , Sequence ]] = None , unit : str = 'q' , mask : np . ndarray = None , solid_angle : bool = True , polarization_factor : Optional [ float ] = None , error_model : Optional [ str ] = None ): \"\"\" Args: poni_file: Name of Poni file that sets up the geometry of the integrator shape: Shape of the images to be integrated pixel_size: Pixel size of detector n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually radial_bins: radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1. azimuth_bins: azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees. unit: Ouput units for the radial coordindate mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded solid_angle: Perform solid angle correction polarization_factor: Polarization factor for the polarization correction 1 (linear horizontal polarization) -1 (linear vertical polarization) Attributes: radial_axis (ndarray): radial axis depeding on units in q or 2theta azimuth_axis (ndarray, optional): azimuth axis in degrees is case of 2D integration \"\"\" if error_model and error_model != 'poisson' : raise RuntimeError ( 'Only poisson error model is supported' ) if error_model and n_splitting > 1 : raise RuntimeError ( 'Cannot estimate errors with pixel splitting. \\n Set n_splitting to 1 for error estimation' ) if unit not in ( 'q' , '2th' ): raise RuntimeError ( 'Wrong radial unit. Allowed units: q, 2th' ) self . unit = unit self . error_model = error_model self . polarization_factor = polarization_factor self . poni = Poni ( poni_file ) if mask is None : mask = np . zeros ( shape , dtype = np . uint8 ) elif mask . shape != shape : raise RuntimeError ( 'Img shape %s is different from mask shape %s ' % ( shape , mask . shape )) p1 , p2 = calc_coordinates ( shape , pixel_size , self . poni ) p3 = np . ones ( np . prod ( shape ), dtype = np . float32 ) * self . poni . dist pos = np . dot ( rotation_matrix ( self . poni ), np . vstack (( p1 . reshape ( - 1 ), p2 . reshape ( - 1 ), p3 ))) r = np . sqrt ( pos [ 0 ] ** 2 + pos [ 1 ] ** 2 ) tth = np . arctan2 ( r , pos [ 2 ]) # calculate auto range min/max radial bins if not isinstance ( radial_bins , Iterable ): if unit == 'q' : # q = 4pi/lambda sin( 2theta / 2 ) in A-1 q = 4.0e-10 * np . pi / self . poni . wavelength * np . sin ( 0.5 * tth ) radial_bins = np . linspace ( np . amin ( q ), np . amax ( q ), radial_bins + 1 ) self . radial_axis = 0.5 * ( radial_bins [ 1 :] + radial_bins [: - 1 ]) elif unit == '2th' : radial_bins = np . linspace ( np . amin ( tth ), np . amax ( tth ), radial_bins + 1 ) self . radial_axis = np . rad2deg ( 0.5 * ( radial_bins [ 1 :] + radial_bins [: - 1 ])) bins = [ radial_bins ] self . azimuth_axis = None if azimuth_bins is not None : if not isinstance ( azimuth_bins , Iterable ): azimuth_bins = np . linspace ( 0 , 360 , azimuth_bins + 1 ) self . azimuth_axis = 0.5 * ( azimuth_bins [ 1 :] + azimuth_bins [: - 1 ]) bins . append ( azimuth_bins ) self . input_size = np . prod ( shape ) self . output_shape = [ len ( axis ) - 1 for axis in bins [:: - 1 ]] self . sparse_matrix = Sparse ( self . poni , shape , pixel_size , n_splitting , mask , bins , unit ) self . corrections = np . ones ( shape [ 0 ] * shape [ 1 ], dtype = np . float32 ) if solid_angle : solid_angle = self . poni . dist / np . sqrt ( self . poni . dist ** 2 + p1 * p1 + p2 * p2 ) self . corrections *= ( solid_angle ** 3 ) . reshape ( - 1 ) if polarization_factor : phi = np . arctan2 ( pos [ 0 ], pos [ 1 ]) cos2_tth = np . cos ( tth ) ** 2 polarization = 0.5 * ( 1.0 + cos2_tth - polarization_factor * np . cos ( 2.0 * ( phi )) * ( 1.0 - cos2_tth )) self . corrections *= polarization . reshape ( - 1 ) self . norm = self . sparse_matrix . spmv ( self . corrections ) integrate ( self , img , mask = None ) Calculate the azimuthal integrated profile Parameters: Name Type Description Default img ndarray Input image to be integrated required mask Optional[numpy.ndarray] Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient None Returns: Type Description tuple azimuthal integrated image and optionally error estimate sigma when error_model is specified Source code in azint/azint.py def integrate ( self , img : np . ndarray , mask : Optional [ np . ndarray ] = None ) -> tuple [ np . ndarray , Optional [ np . ndarray ]]: \"\"\" Calculate the azimuthal integrated profile Args: img: Input image to be integrated mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient Returns: azimuthal integrated image and optionally error estimate sigma when error_model is specified \"\"\" if img . size != self . input_size : raise RuntimeError ( 'Size of image is wrong! \\n Expected %d \\n Actual size %d ' % ( self . input_size , img . size )) if mask is None : norm = self . norm else : inverted_mask = 1 - mask img = img * inverted_mask norm = self . sparse_matrix . spmv ( inverted_mask . reshape ( - 1 ) * self . corrections ) signal = self . sparse_matrix . spmv ( img ) result = np . divide ( signal , norm , out = np . zeros_like ( signal ), where = norm != 0.0 ) result = result . reshape ( self . output_shape ) if self . error_model : # poisson error model sigma = np . sqrt ( signal ) sigma = np . divide ( sigma , norm , out = np . zeros_like ( sigma ), where = norm != 0.0 ) sigma = sigma . reshape ( self . output_shape ) return result , sigma else : return result , None","title":"azint"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator","text":"This class is an azimuthal integrator","title":"AzimuthalIntegrator"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.__init__","text":"Parameters: Name Type Description Default poni_file str Name of Poni file that sets up the geometry of the integrator required shape tuple Shape of the images to be integrated required pixel_size float Pixel size of detector required n_splitting int Each pixel in the image gets split into (n, n) subpixels that get binned individually required radial_bins Union[int, collections.abc.Sequence] radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1. required azimuth_bins Union[int, collections.abc.Sequence] azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees. None unit str Ouput units for the radial coordindate 'q' mask ndarray Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded None solid_angle bool Perform solid angle correction True polarization_factor Optional[float] Polarization factor for the polarization correction 1 (linear horizontal polarization) -1 (linear vertical polarization) None Attributes: Name Type Description radial_axis ndarray radial axis depeding on units in q or 2theta azimuth_axis ndarray azimuth axis in degrees is case of 2D integration Source code in azint/azint.py def __init__ ( self , poni_file : str , shape : tuple [ int , int ], pixel_size : float , n_splitting : int , radial_bins : Union [ int , Sequence ], azimuth_bins : Optional [ Union [ int , Sequence ]] = None , unit : str = 'q' , mask : np . ndarray = None , solid_angle : bool = True , polarization_factor : Optional [ float ] = None , error_model : Optional [ str ] = None ): \"\"\" Args: poni_file: Name of Poni file that sets up the geometry of the integrator shape: Shape of the images to be integrated pixel_size: Pixel size of detector n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually radial_bins: radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1. azimuth_bins: azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees. unit: Ouput units for the radial coordindate mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded solid_angle: Perform solid angle correction polarization_factor: Polarization factor for the polarization correction 1 (linear horizontal polarization) -1 (linear vertical polarization) Attributes: radial_axis (ndarray): radial axis depeding on units in q or 2theta azimuth_axis (ndarray, optional): azimuth axis in degrees is case of 2D integration \"\"\" if error_model and error_model != 'poisson' : raise RuntimeError ( 'Only poisson error model is supported' ) if error_model and n_splitting > 1 : raise RuntimeError ( 'Cannot estimate errors with pixel splitting. \\n Set n_splitting to 1 for error estimation' ) if unit not in ( 'q' , '2th' ): raise RuntimeError ( 'Wrong radial unit. Allowed units: q, 2th' ) self . unit = unit self . error_model = error_model self . polarization_factor = polarization_factor self . poni = Poni ( poni_file ) if mask is None : mask = np . zeros ( shape , dtype = np . uint8 ) elif mask . shape != shape : raise RuntimeError ( 'Img shape %s is different from mask shape %s ' % ( shape , mask . shape )) p1 , p2 = calc_coordinates ( shape , pixel_size , self . poni ) p3 = np . ones ( np . prod ( shape ), dtype = np . float32 ) * self . poni . dist pos = np . dot ( rotation_matrix ( self . poni ), np . vstack (( p1 . reshape ( - 1 ), p2 . reshape ( - 1 ), p3 ))) r = np . sqrt ( pos [ 0 ] ** 2 + pos [ 1 ] ** 2 ) tth = np . arctan2 ( r , pos [ 2 ]) # calculate auto range min/max radial bins if not isinstance ( radial_bins , Iterable ): if unit == 'q' : # q = 4pi/lambda sin( 2theta / 2 ) in A-1 q = 4.0e-10 * np . pi / self . poni . wavelength * np . sin ( 0.5 * tth ) radial_bins = np . linspace ( np . amin ( q ), np . amax ( q ), radial_bins + 1 ) self . radial_axis = 0.5 * ( radial_bins [ 1 :] + radial_bins [: - 1 ]) elif unit == '2th' : radial_bins = np . linspace ( np . amin ( tth ), np . amax ( tth ), radial_bins + 1 ) self . radial_axis = np . rad2deg ( 0.5 * ( radial_bins [ 1 :] + radial_bins [: - 1 ])) bins = [ radial_bins ] self . azimuth_axis = None if azimuth_bins is not None : if not isinstance ( azimuth_bins , Iterable ): azimuth_bins = np . linspace ( 0 , 360 , azimuth_bins + 1 ) self . azimuth_axis = 0.5 * ( azimuth_bins [ 1 :] + azimuth_bins [: - 1 ]) bins . append ( azimuth_bins ) self . input_size = np . prod ( shape ) self . output_shape = [ len ( axis ) - 1 for axis in bins [:: - 1 ]] self . sparse_matrix = Sparse ( self . poni , shape , pixel_size , n_splitting , mask , bins , unit ) self . corrections = np . ones ( shape [ 0 ] * shape [ 1 ], dtype = np . float32 ) if solid_angle : solid_angle = self . poni . dist / np . sqrt ( self . poni . dist ** 2 + p1 * p1 + p2 * p2 ) self . corrections *= ( solid_angle ** 3 ) . reshape ( - 1 ) if polarization_factor : phi = np . arctan2 ( pos [ 0 ], pos [ 1 ]) cos2_tth = np . cos ( tth ) ** 2 polarization = 0.5 * ( 1.0 + cos2_tth - polarization_factor * np . cos ( 2.0 * ( phi )) * ( 1.0 - cos2_tth )) self . corrections *= polarization . reshape ( - 1 ) self . norm = self . sparse_matrix . spmv ( self . corrections )","title":"__init__()"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.integrate","text":"Calculate the azimuthal integrated profile Parameters: Name Type Description Default img ndarray Input image to be integrated required mask Optional[numpy.ndarray] Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient None Returns: Type Description tuple azimuthal integrated image and optionally error estimate sigma when error_model is specified Source code in azint/azint.py def integrate ( self , img : np . ndarray , mask : Optional [ np . ndarray ] = None ) -> tuple [ np . ndarray , Optional [ np . ndarray ]]: \"\"\" Calculate the azimuthal integrated profile Args: img: Input image to be integrated mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient Returns: azimuthal integrated image and optionally error estimate sigma when error_model is specified \"\"\" if img . size != self . input_size : raise RuntimeError ( 'Size of image is wrong! \\n Expected %d \\n Actual size %d ' % ( self . input_size , img . size )) if mask is None : norm = self . norm else : inverted_mask = 1 - mask img = img * inverted_mask norm = self . sparse_matrix . spmv ( inverted_mask . reshape ( - 1 ) * self . corrections ) signal = self . sparse_matrix . spmv ( img ) result = np . divide ( signal , norm , out = np . zeros_like ( signal ), where = norm != 0.0 ) result = result . reshape ( self . output_shape ) if self . error_model : # poisson error model sigma = np . sqrt ( signal ) sigma = np . divide ( sigma , norm , out = np . zeros_like ( sigma ), where = norm != 0.0 ) sigma = sigma . reshape ( self . output_shape ) return result , sigma else : return result , None","title":"integrate()"}]}