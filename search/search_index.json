{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"azint","text":"<p>azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing  each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins.</p> <p>The algorithm is described in more detail in this publication. Please cite the paper if you use azint.</p> \\[ I_{bin} = \\frac{ \\sum_{pix \\in bin} c^{pix}_{bin} \\frac{I_{pix}}{\\Omega_{pix} P_{pix}}}{\\sum_{pix \\in bin}c^{pix}_{bin}} \\] <p>with the standard error of the mean</p> \\[ SE_{bin} = \\frac{ \\sqrt{\\sum_{pix \\in bin} (c^{pix}_{bin})^2 \\frac{\\sigma^2_{pix}}{\\Omega_{pix}^2 P_{pix}^2}}}{\\sum_{pix \\in bin}c^{pix}_{bin}} \\] <p>The only error model implementent at the moment is the poisson error model with \\(\\sigma_{pix} = \\sqrt{I_{pix}}\\)</p>"},{"location":"#geometry","title":"Geometry","text":"<p>The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI  </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>conda install -c maxiv azint\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>azint is using poni files from pyFAI to setup the azimuthal integrator <pre><code>import fabio\nimport numpy as np\nfrom azint import AzimuthalIntegrator\n\nimg = fabio.open('Eiger4M_Al2O3_13.45keV.edf').data\nmask = fabio.open('mask.tif').data\n# 1D integration\nai = AzimuthalIntegrator('test.poni', \n                          4, \n                          2000,\n                          unit='q',\n                          solid_angle=True,\n                          mask=mask) \nI, error = ai.integrate(img)\n\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.plot(ai.radial_axis, I)\n\n# 2D integration\nai = AzimuthalIntegrator('test.poni', \n                          4, \n                          512, \n                          180, \n                          unit='q',\n                          solid_angle=True,\n                          mask=mask) \nI, error = ai.integrate(img)\nplt.figure()\nplt.imshow(I)\n</code></pre></p>"},{"location":"azint-reference/","title":"azint","text":""},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator","title":"<code>AzimuthalIntegrator</code>","text":"<p>This class is an azimuthal integrator</p> Source code in <code>azint/azint.py</code> <pre><code>class AzimuthalIntegrator():\n\"\"\"\n    This class is an azimuthal integrator \n    \"\"\"\n    def __init__(self,\n                 poni: Union[str, Poni],\n                 n_splitting: int, \n                 radial_bins: Union[int, Sequence],\n                 azimuth_bins: Optional[Union[int, Sequence]] = None,\n                 unit: str = 'q',\n                 mask: np.ndarray = None, \n                 solid_angle: bool = True,\n                 polarization_factor: Optional[float] = None,\n                 error_model: Optional[str] = None):\n\"\"\"\n        Args:\n            poni: Name of Poni file or instance of Poni\n            n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually\n            radial_bins: radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1.\n            azimuth_bins: azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees.\n            unit: Ouput units for the radial coordindate\n            mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded\n            solid_angle: Perform solid angle correction\n            polarization_factor: Polarization factor for the polarization correction\n                1 (linear horizontal polarization)\n                -1 (linear vertical polarization)\n            error_model: Error model used to calculate errors in the transformation. Only options is 'poisson' error model\n\n        Attributes:\n            radial_axis (ndarray): radial axis depeding on units in q or 2theta\n            azimuth_axis (ndarray, optional): azimuth axis in degrees is case of 2D integration\n        \"\"\"\n\n        if error_model and error_model != 'poisson':\n            raise RuntimeError('Only poisson error model is supported')\n\n        if unit not in ('q', '2th'):\n            raise RuntimeError('Wrong radial unit. Allowed units: q, 2th')\n\n        if isinstance(poni, str):\n            poni = Poni.from_file(poni)\n\n        self.unit = unit\n        self.error_model = error_model\n\n        pixel_centers = np.mean(poni.det.pixel_corners, axis=2)\n        p1 = pixel_centers[..., 1] - poni.poni1\n        p2 = pixel_centers[..., 2] - poni.poni2\n        p3 = pixel_centers[..., 0] + poni.dist\n        tth, phi = transform(poni, p1, p2, p3)\n\n        radial_bins = setup_radial_bins(poni, radial_bins, unit, tth)\n        self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n        azimuth_bins = setup_azimuth_bins(azimuth_bins)\n        self.azimuth_axis = 0.5*(azimuth_bins[1:] + azimuth_bins[:-1]) if azimuth_bins is not None else None\n\n        shape = pixel_centers.shape[:2]\n        self.input_size = np.prod(shape)\n        if mask is None:\n            mask = np.zeros(shape, dtype=np.int8)\n\n        if azimuth_bins is None:\n            self.output_shape = [len(radial_bins) - 1]\n        else:\n            self.output_shape = [len(azimuth_bins) - 1, len(radial_bins) - 1]\n\n        self.sparse_matrix = Sparse(poni, poni.det.pixel_corners, n_splitting, \n                                    mask, unit, radial_bins, azimuth_bins)\n        self.norm = self.sparse_matrix.spmv(np.ones(shape[0]*shape[1], dtype=np.float32))\n        corrections = setup_corrections(poni, solid_angle, polarization_factor, p1, p2, tth, phi)\n        self.sparse_matrix.set_correction(corrections)\n\n\n    def integrate(self, \n                  img: np.ndarray, \n                  mask: Optional[np.ndarray] = None,\n                  normalized: Optional[bool] = True) -&gt; tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n\"\"\"\n        Calculates the azimuthal integration of the input image\n\n        Args:\n            img: Input image to be integrated\n            mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in\n                the constructor is more efficient\n            normalized: Whether to return the normalized result or the integrated signal and norm separately\n\n        Returns:\n            azimuthal integrated image or just integrated signal if normalized is True\n            standard error of the mean (SEM) when error_model is specified else None\n            the norm if normalized is False\n        \"\"\"\n        img = np.ascontiguousarray(img)\n\n        if img.size != self.input_size:\n            raise RuntimeError('Size of image is wrong!\\nExpected %d\\nActual size %d' %(self.input_size, img.size))\n        if mask is None:\n            norm = self.norm\n        else:\n            inverted_mask = 1 - mask\n            img = img*inverted_mask\n            norm = self.sparse_matrix.spmv(inverted_mask.reshape(-1))\n\n        signal = self.sparse_matrix.spmv_corrected(img).reshape(self.output_shape)\n        norm = norm.reshape(self.output_shape)\n\n        errors = None\n        if self.error_model:\n            # poisson error model\n            errors = np.sqrt(self.sparse_matrix.spmv_corrected2(img)).reshape(self.output_shape)\n            if normalized:\n                errors = np.divide(errors, norm, out=np.zeros_like(errors), where=norm!=0.0)\n\n        if normalized:\n            result = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n            return result, errors\n        else:\n            return signal, errors, norm\n</code></pre>"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.__init__","title":"<code>__init__(poni, n_splitting, radial_bins, azimuth_bins=None, unit='q', mask=None, solid_angle=True, polarization_factor=None, error_model=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>poni</code> <code>Union[str, Poni]</code> <p>Name of Poni file or instance of Poni</p> required <code>n_splitting</code> <code>int</code> <p>Each pixel in the image gets split into (n, n) subpixels that get binned individually</p> required <code>radial_bins</code> <code>Union[int, Sequence]</code> <p>radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1.</p> required <code>azimuth_bins</code> <code>Optional[Union[int, Sequence]]</code> <p>azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees.</p> <code>None</code> <code>unit</code> <code>str</code> <p>Ouput units for the radial coordindate</p> <code>'q'</code> <code>mask</code> <code>ndarray</code> <p>Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded</p> <code>None</code> <code>solid_angle</code> <code>bool</code> <p>Perform solid angle correction</p> <code>True</code> <code>polarization_factor</code> <code>Optional[float]</code> <p>Polarization factor for the polarization correction 1 (linear horizontal polarization) -1 (linear vertical polarization)</p> <code>None</code> <code>error_model</code> <code>Optional[str]</code> <p>Error model used to calculate errors in the transformation. Only options is 'poisson' error model</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>radial_axis</code> <code>ndarray</code> <p>radial axis depeding on units in q or 2theta</p> <code>azimuth_axis</code> <code>ndarray</code> <p>azimuth axis in degrees is case of 2D integration</p> Source code in <code>azint/azint.py</code> <pre><code>def __init__(self,\n             poni: Union[str, Poni],\n             n_splitting: int, \n             radial_bins: Union[int, Sequence],\n             azimuth_bins: Optional[Union[int, Sequence]] = None,\n             unit: str = 'q',\n             mask: np.ndarray = None, \n             solid_angle: bool = True,\n             polarization_factor: Optional[float] = None,\n             error_model: Optional[str] = None):\n\"\"\"\n    Args:\n        poni: Name of Poni file or instance of Poni\n        n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually\n        radial_bins: radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1.\n        azimuth_bins: azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees.\n        unit: Ouput units for the radial coordindate\n        mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded\n        solid_angle: Perform solid angle correction\n        polarization_factor: Polarization factor for the polarization correction\n            1 (linear horizontal polarization)\n            -1 (linear vertical polarization)\n        error_model: Error model used to calculate errors in the transformation. Only options is 'poisson' error model\n\n    Attributes:\n        radial_axis (ndarray): radial axis depeding on units in q or 2theta\n        azimuth_axis (ndarray, optional): azimuth axis in degrees is case of 2D integration\n    \"\"\"\n\n    if error_model and error_model != 'poisson':\n        raise RuntimeError('Only poisson error model is supported')\n\n    if unit not in ('q', '2th'):\n        raise RuntimeError('Wrong radial unit. Allowed units: q, 2th')\n\n    if isinstance(poni, str):\n        poni = Poni.from_file(poni)\n\n    self.unit = unit\n    self.error_model = error_model\n\n    pixel_centers = np.mean(poni.det.pixel_corners, axis=2)\n    p1 = pixel_centers[..., 1] - poni.poni1\n    p2 = pixel_centers[..., 2] - poni.poni2\n    p3 = pixel_centers[..., 0] + poni.dist\n    tth, phi = transform(poni, p1, p2, p3)\n\n    radial_bins = setup_radial_bins(poni, radial_bins, unit, tth)\n    self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n    azimuth_bins = setup_azimuth_bins(azimuth_bins)\n    self.azimuth_axis = 0.5*(azimuth_bins[1:] + azimuth_bins[:-1]) if azimuth_bins is not None else None\n\n    shape = pixel_centers.shape[:2]\n    self.input_size = np.prod(shape)\n    if mask is None:\n        mask = np.zeros(shape, dtype=np.int8)\n\n    if azimuth_bins is None:\n        self.output_shape = [len(radial_bins) - 1]\n    else:\n        self.output_shape = [len(azimuth_bins) - 1, len(radial_bins) - 1]\n\n    self.sparse_matrix = Sparse(poni, poni.det.pixel_corners, n_splitting, \n                                mask, unit, radial_bins, azimuth_bins)\n    self.norm = self.sparse_matrix.spmv(np.ones(shape[0]*shape[1], dtype=np.float32))\n    corrections = setup_corrections(poni, solid_angle, polarization_factor, p1, p2, tth, phi)\n    self.sparse_matrix.set_correction(corrections)\n</code></pre>"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.integrate","title":"<code>integrate(img, mask=None, normalized=True)</code>","text":"<p>Calculates the azimuthal integration of the input image</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>Input image to be integrated</p> required <code>mask</code> <code>Optional[ndarray]</code> <p>Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient</p> <code>None</code> <code>normalized</code> <code>Optional[bool]</code> <p>Whether to return the normalized result or the integrated signal and norm separately</p> <code>True</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>azimuthal integrated image or just integrated signal if normalized is True</p> <code>ndarray</code> <p>standard error of the mean (SEM) when error_model is specified else None</p> <code>Optional[ndarray]</code> <p>the norm if normalized is False</p> Source code in <code>azint/azint.py</code> <pre><code>def integrate(self, \n              img: np.ndarray, \n              mask: Optional[np.ndarray] = None,\n              normalized: Optional[bool] = True) -&gt; tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:\n\"\"\"\n    Calculates the azimuthal integration of the input image\n\n    Args:\n        img: Input image to be integrated\n        mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in\n            the constructor is more efficient\n        normalized: Whether to return the normalized result or the integrated signal and norm separately\n\n    Returns:\n        azimuthal integrated image or just integrated signal if normalized is True\n        standard error of the mean (SEM) when error_model is specified else None\n        the norm if normalized is False\n    \"\"\"\n    img = np.ascontiguousarray(img)\n\n    if img.size != self.input_size:\n        raise RuntimeError('Size of image is wrong!\\nExpected %d\\nActual size %d' %(self.input_size, img.size))\n    if mask is None:\n        norm = self.norm\n    else:\n        inverted_mask = 1 - mask\n        img = img*inverted_mask\n        norm = self.sparse_matrix.spmv(inverted_mask.reshape(-1))\n\n    signal = self.sparse_matrix.spmv_corrected(img).reshape(self.output_shape)\n    norm = norm.reshape(self.output_shape)\n\n    errors = None\n    if self.error_model:\n        # poisson error model\n        errors = np.sqrt(self.sparse_matrix.spmv_corrected2(img)).reshape(self.output_shape)\n        if normalized:\n            errors = np.divide(errors, norm, out=np.zeros_like(errors), where=norm!=0.0)\n\n    if normalized:\n        result = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n        return result, errors\n    else:\n        return signal, errors, norm\n</code></pre>"}]}