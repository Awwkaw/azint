{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"azint azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins. Geometry The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI Installation conda install -c maxiv azint Getting started azint is using poni files from pyFAI to setup the azimuthal integrator import fabio import numpy as np from azint import AzimuthalIntegrator img = fabio . open ( 'Eiger4M_Al2O3_13.45keV.edf' ) . data mask = fabio . open ( 'mask.tif' ) . data # 1D integration ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , [ 2000 ,], solid_angle = True ) res = ai . integrate ( img ) import matplotlib.pyplot as plt plt . figure () plt . plot ( ai . q , res ) # 2D integration phi_bins = np . linspace ( - np . pi , np . pi , 121 ) ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , [ 512 , phi_bins ], solid_angle = True ) res = ai . integrate ( img ) plt . figure () plt . imshow ( res )","title":"Home"},{"location":"#azint","text":"azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins.","title":"azint"},{"location":"#geometry","text":"The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI","title":"Geometry"},{"location":"#installation","text":"conda install -c maxiv azint","title":"Installation"},{"location":"#getting-started","text":"azint is using poni files from pyFAI to setup the azimuthal integrator import fabio import numpy as np from azint import AzimuthalIntegrator img = fabio . open ( 'Eiger4M_Al2O3_13.45keV.edf' ) . data mask = fabio . open ( 'mask.tif' ) . data # 1D integration ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , [ 2000 ,], solid_angle = True ) res = ai . integrate ( img ) import matplotlib.pyplot as plt plt . figure () plt . plot ( ai . q , res ) # 2D integration phi_bins = np . linspace ( - np . pi , np . pi , 121 ) ai = AzimuthalIntegrator ( 'test.poni' , mask . shape , 75.0e-6 , 4 , [ 512 , phi_bins ], solid_angle = True ) res = ai . integrate ( img ) plt . figure () plt . imshow ( res )","title":"Getting started"},{"location":"azint-reference/","text":"AzimuthalIntegrator This class is an azimuthal integrator __init__ ( self , poni_file , shape , pixel_size , n_splitting , bins , mask = None , solid_angle = True ) special Parameters: Name Type Description Default poni_file str Name of Poni file that sets up the geometry of the integrator required shape tuple Shape of the images to be integrated required pixel_size float Pixel size of detector required n_splitting int Each pixel in the image gets split into (n, n) subpixels that get binned individually required bins list list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence required mask ndarray Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded None solid_angle bool Perform solid angle correction True Attributes: Name Type Description q ndarray q bins defined as q = 4pi/lambda sin(theta) in nm-1 phi ndarray phi bins is case of 2D integration Source code in azint/azint.py def __init__ ( self , poni_file : str , shape : tuple [ int , int ], pixel_size : float , n_splitting : int , bins : list [ Union [ int , Sequence ], Optional [ Sequence ]], mask : np . ndarray = None , solid_angle : bool = True ): \"\"\" Args: poni_file: Name of Poni file that sets up the geometry of the integrator shape: Shape of the images to be integrated pixel_size: Pixel size of detector n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually bins: list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded solid_angle: Perform solid angle correction Attributes: q (ndarray): q bins defined as q = 4pi/lambda sin(theta) in nm-1 phi (ndarray, optional): phi bins is case of 2D integration \"\"\" self . poni = Poni ( poni_file ) qbins = bins [ 0 ] if not any ([ isinstance ( qbins , np . ndarray ), isinstance ( qbins , list )]): minq = calculate_minq ( shape , self . poni , pixel_size ) maxq = calculate_maxq ( shape , self . poni , pixel_size ) bins [ 0 ] = np . linspace ( minq , maxq , qbins + 1 ) self . q = 0.5 * ( bins [ 0 ][ 1 :] + bins [ 0 ][: - 1 ]) if len ( bins ) == 2 : self . phi = 0.5 * ( bins [ 1 ][ 1 :] + bins [ 1 ][: - 1 ]) else : self . phi = None if mask is None : mask = np . zeros ( shape , dtype = np . uint8 ) self . output_shape = [ len ( axis ) - 1 for axis in bins [:: - 1 ]] self . sparse_matrix = Sparse ( self . poni , shape , pixel_size , n_splitting , mask , bins ) if solid_angle : d1 = ( np . arange ( shape [ 0 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni1 d2 = ( np . arange ( shape [ 1 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni2 p1 , p2 = np . meshgrid ( d2 , d1 ) solid_angle = self . poni . dist / np . sqrt ( self . poni . dist ** 2 + p1 * p1 + p2 * p2 ) self . norm = self . sparse_matrix . spmv ( solid_angle ** 3 ) self . correction = solid_angle ** 3 else : self . correction = None self . norm = self . sparse_matrix . spmv ( np . ones ( shape [ 0 ] * shape [ 1 ], dtype = np . float32 )) integrate ( self , img , mask = None ) Calculate the azimuthal integrated profile Parameters: Name Type Description Default img ndarray Input image to be integrated required mask ndarray Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient None Returns: Type Description ndarray azimuthal integrated image Source code in azint/azint.py def integrate ( self , img : np . ndarray , mask : np . ndarray = None ) -> np . ndarray : \"\"\" Calculate the azimuthal integrated profile Args: img: Input image to be integrated mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient Returns: azimuthal integrated image \"\"\" if mask is None : norm = self . norm else : inverted_mask = 1 - mask img = img * inverted_mask if self . correction is not None : norm = self . sparse_matrix . spmv ( inverted_mask * self . correction ) else : norm = self . sparse_matrix . spmv ( inverted_mask ) signal = self . sparse_matrix . spmv ( img ) result = np . divide ( signal , norm , out = np . zeros_like ( signal ), where = self . norm != 0.0 ) return result . reshape ( self . output_shape )","title":"azint"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator","text":"This class is an azimuthal integrator","title":"AzimuthalIntegrator"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.__init__","text":"Parameters: Name Type Description Default poni_file str Name of Poni file that sets up the geometry of the integrator required shape tuple Shape of the images to be integrated required pixel_size float Pixel size of detector required n_splitting int Each pixel in the image gets split into (n, n) subpixels that get binned individually required bins list list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence required mask ndarray Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded None solid_angle bool Perform solid angle correction True Attributes: Name Type Description q ndarray q bins defined as q = 4pi/lambda sin(theta) in nm-1 phi ndarray phi bins is case of 2D integration Source code in azint/azint.py def __init__ ( self , poni_file : str , shape : tuple [ int , int ], pixel_size : float , n_splitting : int , bins : list [ Union [ int , Sequence ], Optional [ Sequence ]], mask : np . ndarray = None , solid_angle : bool = True ): \"\"\" Args: poni_file: Name of Poni file that sets up the geometry of the integrator shape: Shape of the images to be integrated pixel_size: Pixel size of detector n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually bins: list of q and optionally phi bins. q bins can either be number of bins or a sequence defining the bin edges. Phi bins is a sequence mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded solid_angle: Perform solid angle correction Attributes: q (ndarray): q bins defined as q = 4pi/lambda sin(theta) in nm-1 phi (ndarray, optional): phi bins is case of 2D integration \"\"\" self . poni = Poni ( poni_file ) qbins = bins [ 0 ] if not any ([ isinstance ( qbins , np . ndarray ), isinstance ( qbins , list )]): minq = calculate_minq ( shape , self . poni , pixel_size ) maxq = calculate_maxq ( shape , self . poni , pixel_size ) bins [ 0 ] = np . linspace ( minq , maxq , qbins + 1 ) self . q = 0.5 * ( bins [ 0 ][ 1 :] + bins [ 0 ][: - 1 ]) if len ( bins ) == 2 : self . phi = 0.5 * ( bins [ 1 ][ 1 :] + bins [ 1 ][: - 1 ]) else : self . phi = None if mask is None : mask = np . zeros ( shape , dtype = np . uint8 ) self . output_shape = [ len ( axis ) - 1 for axis in bins [:: - 1 ]] self . sparse_matrix = Sparse ( self . poni , shape , pixel_size , n_splitting , mask , bins ) if solid_angle : d1 = ( np . arange ( shape [ 0 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni1 d2 = ( np . arange ( shape [ 1 ], dtype = np . float32 ) + 0.5 ) * pixel_size - self . poni . poni2 p1 , p2 = np . meshgrid ( d2 , d1 ) solid_angle = self . poni . dist / np . sqrt ( self . poni . dist ** 2 + p1 * p1 + p2 * p2 ) self . norm = self . sparse_matrix . spmv ( solid_angle ** 3 ) self . correction = solid_angle ** 3 else : self . correction = None self . norm = self . sparse_matrix . spmv ( np . ones ( shape [ 0 ] * shape [ 1 ], dtype = np . float32 ))","title":"__init__()"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.integrate","text":"Calculate the azimuthal integrated profile Parameters: Name Type Description Default img ndarray Input image to be integrated required mask ndarray Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient None Returns: Type Description ndarray azimuthal integrated image Source code in azint/azint.py def integrate ( self , img : np . ndarray , mask : np . ndarray = None ) -> np . ndarray : \"\"\" Calculate the azimuthal integrated profile Args: img: Input image to be integrated mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient Returns: azimuthal integrated image \"\"\" if mask is None : norm = self . norm else : inverted_mask = 1 - mask img = img * inverted_mask if self . correction is not None : norm = self . sparse_matrix . spmv ( inverted_mask * self . correction ) else : norm = self . sparse_matrix . spmv ( inverted_mask ) signal = self . sparse_matrix . spmv ( img ) result = np . divide ( signal , norm , out = np . zeros_like ( signal ), where = self . norm != 0.0 ) return result . reshape ( self . output_shape )","title":"integrate()"}]}