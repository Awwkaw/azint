{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"azint","text":"<p>azint is a python library for azimuthal integration of area detectors. The azimuthal integration is transformed into a sparse matrix vector multiplication for performance. Pixel splitting is done by subdividing  each pixels into subpixels and assigning bins and weights for the individual subpixels. This can increase the precision of the transformation but also introduces correlation between neighboring bins.</p> \\[ I_{bin} = \\frac{\\sum_{pix \\in bin} c^{pix}_{bin}I_{pix}}{\\sum_{pix \\in bin} c^{pix}_{bin}\\Omega_{pix}P_{pix}} \\]"},{"location":"#geometry","title":"Geometry","text":"<p>The geometry in azint is identical to pyFAI to be compatible with poni files generated by pyFAI  </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>conda install -c maxiv azint\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<p>azint is using poni files from pyFAI to setup the azimuthal integrator <pre><code>import fabio\nimport numpy as np\nfrom azint import AzimuthalIntegrator\n\nimg = fabio.open('Eiger4M_Al2O3_13.45keV.edf').data\nmask = fabio.open('mask.tif').data\n# 1D integration\nai = AzimuthalIntegrator('test.poni', \n                          mask.shape, \n                          75.0e-6, 4, \n                          2000,\n                          unit='q',\n                          solid_angle=True,\n                          mask=mask) \nI, error = ai.integrate(img)\n\nimport matplotlib.pyplot as plt\nplt.figure()\nplt.plot(ai.radial_axis, I)\n\n# 2D integration\nai = AzimuthalIntegrator('test.poni', \n                          mask.shape, \n                          75.0e-6, 4, \n                          512, \n                          180, \n                          unit='q',\n                          solid_angle=True,\n                          mask=mask) \nI, error = ai.integrate(img)\nplt.figure()\nplt.imshow(I)\n</code></pre></p>"},{"location":"azint-reference/","title":"azint","text":""},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator","title":"<code>AzimuthalIntegrator</code>","text":"<p>This class is an azimuthal integrator</p> Source code in <code>azint/azint.py</code> <pre><code>class AzimuthalIntegrator():\n\"\"\"\n    This class is an azimuthal integrator \n    \"\"\"\n    def __init__(self, \n                 poni_file: str, \n                 shape: tuple[int, int], \n                 pixel_size: float, \n                 n_splitting: int, \n                 radial_bins: Union[int, Sequence],\n                 azimuth_bins: Optional[Union[int, Sequence]] = None,\n                 unit: str = 'q',\n                 mask: np.ndarray = None, \n                 solid_angle: bool = True,\n                 polarization_factor: Optional[float] = None,\n                 error_model: Optional[str] = None):\n\"\"\"\n        Args:\n            poni_file: Name of Poni file that sets up the geometry\n                of the integrator\n            shape: Shape of the images to be integrated\n            pixel_size: Pixel size of detector\n            n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually\n            radial_bins: radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1.\n            azimuth_bins: azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees.\n            unit: Ouput units for the radial coordindate\n            mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded\n            solid_angle: Perform solid angle correction\n            polarization_factor: Polarization factor for the polarization correction\n                1 (linear horizontal polarization)\n                -1 (linear vertical polarization)\n\n        Attributes:\n            radial_axis (ndarray): radial axis depeding on units in q or 2theta\n            azimuth_axis (ndarray, optional): azimuth axis in degrees is case of 2D integration\n        \"\"\"\n\n        if error_model and error_model != 'poisson':\n            raise RuntimeError('Only poisson error model is supported')\n\n        if error_model and n_splitting &gt; 1:\n            raise RuntimeError('Cannot estimate errors with pixel splitting.\\n Set n_splitting to 1 for error estimation')\n\n        if unit not in ('q', '2th'):\n            raise RuntimeError('Wrong radial unit. Allowed units: q, 2th')\n\n        self.unit = unit\n        self.error_model = error_model\n        self.polarization_factor = polarization_factor\n        self.poni = Poni(poni_file)\n\n        if mask is None:\n            mask = np.zeros(shape, dtype=np.uint8)\n        elif mask.shape != shape:\n            raise RuntimeError('Img shape %s is different from mask shape %s' %(shape, mask.shape))\n\n        p1, p2 = calc_coordinates(shape, pixel_size, self.poni)\n        p3 = np.ones(np.prod(shape), dtype=np.float32)*self.poni.dist\n        pos = np.dot(rotation_matrix(self.poni), \n                         np.vstack((p1.reshape(-1), p2.reshape(-1), p3)))\n        r = np.sqrt(pos[0]**2 + pos[1]**2)\n        tth = np.arctan2(r, pos[2])\n\n        if unit == 'q':\n            # calculate auto range min/max radial bins\n            if not isinstance(radial_bins, Iterable):\n                # q = 4pi/lambda sin( 2theta / 2 ) in A-1\n                q = 4.0e-10 * np.pi / self.poni.wavelength * np.sin(0.5*tth)\n                radial_bins = np.linspace(np.amin(q), np.amax(q), radial_bins+1)\n            else:\n                radial_bins = np.asarray(radial_bins)\n\n            self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n\n        elif unit == '2th':\n            if not isinstance(radial_bins, Iterable):\n                radial_bins = np.linspace(np.amin(tth), np.amax(tth), radial_bins+1)\n                self.radial_axis = np.rad2deg(0.5*(radial_bins[1:] + radial_bins[:-1]))\n            # custom q range in degrees\n            else:\n                self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n                radial_bins = np.deg2rad(radial_bins)\n\n        bins = [radial_bins]\n\n        self.azimuth_axis = None\n        if azimuth_bins is not None:\n            if not isinstance(azimuth_bins, Iterable):\n                azimuth_bins = np.linspace(0, 360, azimuth_bins+1)\n            self.azimuth_axis = 0.5*(azimuth_bins[1:] + azimuth_bins[:-1])\n            bins.append(azimuth_bins)\n\n        self.input_size = np.prod(shape)\n        self.output_shape = [len(axis)-1 for axis in bins[::-1]]\n        self.sparse_matrix = Sparse(self.poni, shape, pixel_size, n_splitting, mask, bins, unit)\n        self.corrections = np.ones(shape[0]*shape[1], dtype=np.float32)\n        if solid_angle:\n            solid_angle = self.poni.dist / np.sqrt(self.poni.dist**2 + p1*p1 + p2*p2)\n            self.corrections *= (solid_angle**3).reshape(-1)\n\n        if polarization_factor:\n            phi = np.arctan2(pos[0], pos[1])\n            cos2_tth = np.cos(tth) ** 2\n            polarization = 0.5 * (1.0 + cos2_tth - polarization_factor * np.cos(2.0 * (phi)) * (1.0 - cos2_tth))\n            self.corrections *= polarization.reshape(-1)\n\n        self.norm = self.sparse_matrix.spmv(self.corrections)\n\n    def integrate(self, \n                  img: np.ndarray, \n                  mask: Optional[np.ndarray] = None,\n                  normalized: bool = True) -&gt; tuple[np.ndarray, Optional[np.ndarray], Optional[np.ndarray]]:\n\"\"\"\n        Calculate the azimuthal integration of the input image\n        Args:\n            img: Input image to be integrated\n            mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in\n                the constructor is more efficient\n            normalized: Whether to return the normalized result or the integrated signal and norm separately\n        Returns:\n            azimuthal integrated image or just integrated signal if normalized is True\n            standard error of the mean (SEM) when error_model is specified else None\n            the norm if normalized is False\n        \"\"\"\n        if img.size != self.input_size:\n            raise RuntimeError('Size of image is wrong!\\nExpected %d\\nActual size %d' %(self.input_size, img.size))\n        if mask is None:\n            norm = self.norm\n        else:\n            inverted_mask = 1 - mask\n            img = img*inverted_mask\n            norm = self.sparse_matrix.spmv(inverted_mask.reshape(-1)*self.corrections)\n\n        signal = self.sparse_matrix.spmv(img).reshape(self.output_shape)\n        norm = norm.reshape(self.output_shape)\n\n        errors = None\n        if self.error_model:\n            # poisson error model\n            errors = np.sqrt(signal)\n            errors = errors.reshape(self.output_shape)\n\n        if normalized:\n            result = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n            if errors is not None:\n                errors = np.divide(errors, norm, out=np.zeros_like(errors), where=norm!=0.0)\n            return result, errors\n        else:\n            return signal, errors, norm\n</code></pre>"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.__init__","title":"<code>__init__(poni_file, shape, pixel_size, n_splitting, radial_bins, azimuth_bins=None, unit='q', mask=None, solid_angle=True, polarization_factor=None, error_model=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>poni_file</code> <code>str</code> <p>Name of Poni file that sets up the geometry of the integrator</p> required <code>shape</code> <code>tuple[int, int]</code> <p>Shape of the images to be integrated</p> required <code>pixel_size</code> <code>float</code> <p>Pixel size of detector</p> required <code>n_splitting</code> <code>int</code> <p>Each pixel in the image gets split into (n, n) subpixels that get binned individually</p> required <code>radial_bins</code> <code>Union[int, Sequence]</code> <p>radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1.</p> required <code>azimuth_bins</code> <code>Optional[Union[int, Sequence]]</code> <p>azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees.</p> <code>None</code> <code>unit</code> <code>str</code> <p>Ouput units for the radial coordindate</p> <code>'q'</code> <code>mask</code> <code>np.ndarray</code> <p>Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded</p> <code>None</code> <code>solid_angle</code> <code>bool</code> <p>Perform solid angle correction</p> <code>True</code> <code>polarization_factor</code> <code>Optional[float]</code> <p>Polarization factor for the polarization correction 1 (linear horizontal polarization) -1 (linear vertical polarization)</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>radial_axis</code> <code>ndarray</code> <p>radial axis depeding on units in q or 2theta</p> <code>azimuth_axis</code> <code>ndarray</code> <p>azimuth axis in degrees is case of 2D integration</p> Source code in <code>azint/azint.py</code> <pre><code>def __init__(self, \n             poni_file: str, \n             shape: tuple[int, int], \n             pixel_size: float, \n             n_splitting: int, \n             radial_bins: Union[int, Sequence],\n             azimuth_bins: Optional[Union[int, Sequence]] = None,\n             unit: str = 'q',\n             mask: np.ndarray = None, \n             solid_angle: bool = True,\n             polarization_factor: Optional[float] = None,\n             error_model: Optional[str] = None):\n\"\"\"\n    Args:\n        poni_file: Name of Poni file that sets up the geometry\n            of the integrator\n        shape: Shape of the images to be integrated\n        pixel_size: Pixel size of detector\n        n_splitting: Each pixel in the image gets split into (n, n) subpixels that get binned individually\n        radial_bins: radial bins can either be number of bins or a sequence defining the bin edges in Angstrom^-1.\n        azimuth_bins: azimthual bins can either be number of bins or a sequence defining the bin edges between [0, 360] degrees.\n        unit: Ouput units for the radial coordindate\n        mask: Pixel mask to exclude bad pixels. Pixels marked with 1 will be excluded\n        solid_angle: Perform solid angle correction\n        polarization_factor: Polarization factor for the polarization correction\n            1 (linear horizontal polarization)\n            -1 (linear vertical polarization)\n\n    Attributes:\n        radial_axis (ndarray): radial axis depeding on units in q or 2theta\n        azimuth_axis (ndarray, optional): azimuth axis in degrees is case of 2D integration\n    \"\"\"\n\n    if error_model and error_model != 'poisson':\n        raise RuntimeError('Only poisson error model is supported')\n\n    if error_model and n_splitting &gt; 1:\n        raise RuntimeError('Cannot estimate errors with pixel splitting.\\n Set n_splitting to 1 for error estimation')\n\n    if unit not in ('q', '2th'):\n        raise RuntimeError('Wrong radial unit. Allowed units: q, 2th')\n\n    self.unit = unit\n    self.error_model = error_model\n    self.polarization_factor = polarization_factor\n    self.poni = Poni(poni_file)\n\n    if mask is None:\n        mask = np.zeros(shape, dtype=np.uint8)\n    elif mask.shape != shape:\n        raise RuntimeError('Img shape %s is different from mask shape %s' %(shape, mask.shape))\n\n    p1, p2 = calc_coordinates(shape, pixel_size, self.poni)\n    p3 = np.ones(np.prod(shape), dtype=np.float32)*self.poni.dist\n    pos = np.dot(rotation_matrix(self.poni), \n                     np.vstack((p1.reshape(-1), p2.reshape(-1), p3)))\n    r = np.sqrt(pos[0]**2 + pos[1]**2)\n    tth = np.arctan2(r, pos[2])\n\n    if unit == 'q':\n        # calculate auto range min/max radial bins\n        if not isinstance(radial_bins, Iterable):\n            # q = 4pi/lambda sin( 2theta / 2 ) in A-1\n            q = 4.0e-10 * np.pi / self.poni.wavelength * np.sin(0.5*tth)\n            radial_bins = np.linspace(np.amin(q), np.amax(q), radial_bins+1)\n        else:\n            radial_bins = np.asarray(radial_bins)\n\n        self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n\n    elif unit == '2th':\n        if not isinstance(radial_bins, Iterable):\n            radial_bins = np.linspace(np.amin(tth), np.amax(tth), radial_bins+1)\n            self.radial_axis = np.rad2deg(0.5*(radial_bins[1:] + radial_bins[:-1]))\n        # custom q range in degrees\n        else:\n            self.radial_axis = 0.5*(radial_bins[1:] + radial_bins[:-1])\n            radial_bins = np.deg2rad(radial_bins)\n\n    bins = [radial_bins]\n\n    self.azimuth_axis = None\n    if azimuth_bins is not None:\n        if not isinstance(azimuth_bins, Iterable):\n            azimuth_bins = np.linspace(0, 360, azimuth_bins+1)\n        self.azimuth_axis = 0.5*(azimuth_bins[1:] + azimuth_bins[:-1])\n        bins.append(azimuth_bins)\n\n    self.input_size = np.prod(shape)\n    self.output_shape = [len(axis)-1 for axis in bins[::-1]]\n    self.sparse_matrix = Sparse(self.poni, shape, pixel_size, n_splitting, mask, bins, unit)\n    self.corrections = np.ones(shape[0]*shape[1], dtype=np.float32)\n    if solid_angle:\n        solid_angle = self.poni.dist / np.sqrt(self.poni.dist**2 + p1*p1 + p2*p2)\n        self.corrections *= (solid_angle**3).reshape(-1)\n\n    if polarization_factor:\n        phi = np.arctan2(pos[0], pos[1])\n        cos2_tth = np.cos(tth) ** 2\n        polarization = 0.5 * (1.0 + cos2_tth - polarization_factor * np.cos(2.0 * (phi)) * (1.0 - cos2_tth))\n        self.corrections *= polarization.reshape(-1)\n\n    self.norm = self.sparse_matrix.spmv(self.corrections)\n</code></pre>"},{"location":"azint-reference/#azint.azint.AzimuthalIntegrator.integrate","title":"<code>integrate(img, mask=None, normalized=True)</code>","text":"<p>Calculate the azimuthal integration of the input image</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>np.ndarray</code> <p>Input image to be integrated</p> required <code>mask</code> <code>Optional[np.ndarray]</code> <p>Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in the constructor is more efficient</p> <code>None</code> <code>normalized</code> <code>bool</code> <p>Whether to return the normalized result or the integrated signal and norm separately</p> <code>True</code> <p>Returns:</p> Type Description <code>np.ndarray</code> <p>azimuthal integrated image or just integrated signal if normalized is True</p> <code>Optional[np.ndarray]</code> <p>standard error of the mean (SEM) when error_model is specified else None</p> <code>Optional[np.ndarray]</code> <p>the norm if normalized is False</p> Source code in <code>azint/azint.py</code> <pre><code>def integrate(self, \n              img: np.ndarray, \n              mask: Optional[np.ndarray] = None,\n              normalized: bool = True) -&gt; tuple[np.ndarray, Optional[np.ndarray], Optional[np.ndarray]]:\n\"\"\"\n    Calculate the azimuthal integration of the input image\n    Args:\n        img: Input image to be integrated\n        mask: Optional pixel mask to exclude bad pixels. Note if mask is constant using the mask argument in\n            the constructor is more efficient\n        normalized: Whether to return the normalized result or the integrated signal and norm separately\n    Returns:\n        azimuthal integrated image or just integrated signal if normalized is True\n        standard error of the mean (SEM) when error_model is specified else None\n        the norm if normalized is False\n    \"\"\"\n    if img.size != self.input_size:\n        raise RuntimeError('Size of image is wrong!\\nExpected %d\\nActual size %d' %(self.input_size, img.size))\n    if mask is None:\n        norm = self.norm\n    else:\n        inverted_mask = 1 - mask\n        img = img*inverted_mask\n        norm = self.sparse_matrix.spmv(inverted_mask.reshape(-1)*self.corrections)\n\n    signal = self.sparse_matrix.spmv(img).reshape(self.output_shape)\n    norm = norm.reshape(self.output_shape)\n\n    errors = None\n    if self.error_model:\n        # poisson error model\n        errors = np.sqrt(signal)\n        errors = errors.reshape(self.output_shape)\n\n    if normalized:\n        result = np.divide(signal, norm, out=np.zeros_like(signal), where=norm!=0.0)\n        if errors is not None:\n            errors = np.divide(errors, norm, out=np.zeros_like(errors), where=norm!=0.0)\n        return result, errors\n    else:\n        return signal, errors, norm\n</code></pre>"}]}